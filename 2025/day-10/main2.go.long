package main

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"strconv"
	"strings"
)

func parseLine(line string) ([]int, [][]int, bool) {
	// Parse targets {3,5,4}
	targetRe := regexp.MustCompile(`\{([\d,]+)\}`)
	tm := targetRe.FindStringSubmatch(line)
	if tm == nil {
		return nil, nil, false
	}
	targetStr := strings.Split(tm[1], ",")
	targets := make([]int, len(targetStr))
	for i, s := range targetStr {
		v, _ := strconv.Atoi(s)
		targets[i] = v
	}

	// Parse buttons (1,3), (2)
	buttonRe := regexp.MustCompile(`\(([\d,]+)\)`)
	buttonMatches := buttonRe.FindAllStringSubmatch(line, -1)
	buttons := make([][]int, len(buttonMatches))
	for i, bm := range buttonMatches {
		parts := strings.Split(bm[1], ",")
		btn := make([]int, len(parts))
		for j, p := range parts {
			v, _ := strconv.Atoi(p)
			btn[j] = v
		}
		buttons[i] = btn
	}

	return targets, buttons, true
}

func solve(filename string) {
	file, err := os.Open(filename)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	totalMinPresses := 0
	machinesProcessed := 0

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}

		targets, buttons, ok := parseLine(line)
		if !ok {
			continue
		}

		n := len(targets)
		m := len(buttons)
		matrix := make([][]int, n)
		for i := range matrix {
			matrix[i] = make([]int, m)
		}
		buttonLimits := make([]int, m)
		for i := range buttonLimits {
			buttonLimits[i] = 1 << 30
		}

		for col, btn := range buttons {
			for _, r := range btn {
				if r < n {
					matrix[r][col] = 1
					if targets[r] < buttonLimits[col] {
						buttonLimits[col] = targets[r]
					}
				}
			}
		}

		minPresses := 1 << 30

		// Recursive search over free variables
		var dfs func(idx int, vals []int)
		dfs = func(idx int, vals []int) {
			if idx == m {
				counts := make([]int, n)
				for i := 0; i < m; i++ {
					for r := 0; r < n; r++ {
						counts[r] += matrix[r][i] * vals[i]
					}
				}
				valid := true
				sum := 0
				for i := 0; i < n; i++ {
					if counts[i] != targets[i] {
						valid = false
						break
					}
					sum += counts[i]
				}
				if valid && sum < minPresses {
					minPresses = sum
				}
				return
			}
			for v := 0; v <= buttonLimits[idx]; v++ {
				dfs(idx+1, append(vals, v))
			}
		}

		dfs(0, []int{})
		if minPresses < 1<<30 {
			totalMinPresses += minPresses
			machinesProcessed++
		}
	}

	fmt.Println("Processed", machinesProcessed, "machines")
	fmt.Println("Total fewest presses:", totalMinPresses)
}

func main() {
	solve("input.txt")
}
